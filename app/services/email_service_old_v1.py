# ==============================================================================
# Handles all email-related tasks for the two-phase workflow.
# The ingestion function polls a single mailbox (which can be shared by
# multiple configurations) and uses a dispatcher model to route requests
# to the correct workflow based on the content of the email.
# ==============================================================================


import imaplib
import email
from email.header import decode_header
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import logging
import re
from datetime import datetime


from app.services import db_service, ad_service
from app.services.ai_service import analyze_email


# Regular expression for matching automated email addresses to ignore them.
AUTO_ADDRESS_PATTERNS = [
    r'no-?reply@', r'notification', r'do-?not-?reply@', r'mailer-daemon', r'postmaster@',
    r'automated', r'helpdesk', r'bounces@', r'^noreply', r'bot@', r'listserv',
    r'system@', r'alerts?@'
]


# --- Utility Functions ---


def is_autogenerated_address(email_address):
    """Checks if an email address matches common patterns for automated senders."""
    if not email_address:
        return True
    return any(re.search(pat, email_address, re.IGNORECASE) for pat in AUTO_ADDRESS_PATTERNS)


def extract_email(from_header):
    """Extracts a clean email address from a 'From' header string."""
    if not from_header:
        return None
    match = re.search(r'<([^>]+)>', from_header)
    if match:
        return match.group(1).strip().lower()
    match = re.search(r'[\w.\-+]+@[\w.\-]+', from_header)
    if match:
        return match.group(0).strip().lower()
    return None


def get_email_body(msg):
    """Extracts the plain text body from an email message object."""
    if msg.is_multipart():
        for part in msg.walk():
            content_type = part.get_content_type()
            content_disp = str(part.get("Content-Disposition") or "")
            if content_type == "text/plain" and "attachment" not in content_disp.lower():
                try:
                    return part.get_payload(decode=True).decode()
                except (UnicodeDecodeError, AttributeError):
                    return part.get_payload(decode=True).decode('latin-1', errors='ignore')
    else:
        try:
            return msg.get_payload(decode=True).decode()
        except (UnicodeDecodeError, AttributeError):
            return msg.get_payload(decode=True).decode('latin-1', errors='ignore')
    return ""


def build_search_query(last_check_timestamp):
    """Builds the IMAP search query based on the last check timestamp."""
    search_date = datetime.fromisoformat(last_check_timestamp).strftime('%d-%b-%Y')
    return f'(SINCE "{search_date}")'


def send_email(recipients, subject, body, config):
    """Sends an email using the merged config which contains all necessary credentials."""
    msg = MIMEMultipart()
    msg['From'] = f"{config['team_alias']} <{config['smtp_user']}>"
    msg['To'] = ", ".join(recipients)
    msg['Subject'] = subject
    msg.attach(MIMEText(body, 'plain'))
    try:
        with smtplib.SMTP(config['smtp_server'], config['smtp_port']) as server:
            server.starttls()
            server.login(config['smtp_user'], config['smtp_pass'])
            server.send_message(msg)
            logging.info(f"Sent email '{subject}' to {recipients}")
    except Exception as e:
        logging.error(f"Failed to send email '{subject}' to {recipients}: {e}", exc_info=True)


# Helper function to check if all required approvals are complete
def all_approvals_met(stage_approvals):
    """
    Returns True if for every stage:
    all required approvers are in the approved list (case-insensitive)
    """
    for stage_num_str, stage_data in stage_approvals.items():
        required = {req.lower() for req in stage_data.get('required', [])}
        approved = {app.lower() for app in stage_data.get('approved', [])}
        if not required.issubset(approved):
            return False
    return True


# ==============================================================================
# Phase 1: Ingestion Worker (Read & Record)
# ==============================================================================


def ingest_emails_to_db(mailbox_config, associated_configs, static_config):
    """
    PHASE 1: Polls ONE mailbox and dispatches emails to its associated configurations.
    """
    mailbox_id = mailbox_config['id']
    full_mailbox_config = {**static_config, **mailbox_config}
    last_check_timestamp_key = f"MAILBOX_{mailbox_id}"
    last_check_timestamp = db_service.get_last_check_time(last_check_timestamp_key, full_mailbox_config)
    
    group_config_map = {
        (c.get('required_ad_group') or '').upper(): c
        for c in associated_configs
    }


    try:
        with imaplib.IMAP4_SSL(full_mailbox_config['imap_server']) as mail:
            mail.login(full_mailbox_config['imap_user'], full_mailbox_config['imap_pass'])
            mail.select("INBOX")
            search_query = build_search_query(last_check_timestamp)
            status, message_data = mail.uid('search', None, search_query)
            if status != "OK":
                logging.error(f"[Mailbox ID: {mailbox_id}] IMAP search failed.")
                return


            all_uids = message_data[0].split()
            if all_uids:
                logging.info(f"[Mailbox ID: {mailbox_id}] Found {len(all_uids)} new emails to process.")
            
            for uid in all_uids:
                uid_str = uid.decode()
                if not db_service.claim_uid_for_processing(uid_str):
                    continue


                try:
                    fetch_status, msg_parts = mail.uid('fetch', uid, '(RFC822)')
                    if fetch_status != 'OK' or not msg_parts or not msg_parts[0]:
                        logging.error(f"Failed to fetch email content for UID {uid_str}. Status: {fetch_status}.")
                        continue
                    
                    msg = email.message_from_bytes(msg_parts[0][1])
                    subject, _ = decode_header(msg.get("Subject") or "")[0]
                    if isinstance(subject, bytes): subject = subject.decode('utf-8', 'ignore')
                    
                    sender_email = extract_email(msg.get("From"))
                    if not sender_email or is_autogenerated_address(sender_email):
                        continue


                    body = get_email_body(msg)
                    analysis = analyze_email(subject, body, full_mailbox_config)
                    if not analysis:
                        logging.warning(f"AI analysis for UID {uid_str} failed. Skipping.")
                        continue


                    intent = analysis.get('intent')
                    user_email = analysis.get('user_email')


                    if intent == 'new_request':
                        requested_group = (analysis.get('requested_group') or '').upper()
                        target_config = group_config_map.get(requested_group)
                        if target_config:
                            full_config = {**static_config, **mailbox_config, **target_config}
                            logging.info(f"Preparing new request for user '{user_email}' for config '{target_config['config_id']}'.")

                            # Step 1: Get Stage 1 Approver (Manager)
                            manager_email = ad_service.get_user_manager(user_email, full_config)
                            if not manager_email:
                                logging.error(f"[{target_config['config_id']}] Manager not found for '{user_email}'. Cannot create request.")
                                continue

                            # Step 2: Get Stage 2 Approvers (Group Owners)
                            group_owners = ad_service.get_group_owners(target_config['required_ad_group'], full_config)
                            if not group_owners:
                                logging.error(f"[{target_config['config_id']}] Group owners not found for '{target_config['required_ad_group']}'. Cannot create request.")
                                continue

                            # Step 3: Build the initial stage_approvals structure
                            initial_approvals = {
                                "1": {"required": [manager_email], "approved": []},
                                "2": {"required": group_owners, "approved": []}
                            }

                            # ===== NEW LOGIC START =====
                            # Step 3.5: Auto-approve if the sender or the user themselves is a required approver
                            # in any of the stages.
                            approvers_to_check = {sender_email, user_email}
                            for approver in approvers_to_check:
                                if not approver:
                                    continue
                                for stage_num_str, stage_data in initial_approvals.items():
                                    required_lower = [req.lower() for req in stage_data.get('required', [])]
                                    approved_lower = [app.lower() for app in stage_data.get('approved', [])]
                                    if approver.lower() in required_lower and approver.lower() not in approved_lower:
                                        stage_data['approved'].append(approver.lower())
                                        logging.info(f"Auto-approving stage {stage_num_str} for request for '{user_email}' because '{approver}' is a required approver.")
                            # ===== NEW LOGIC END =====

                            logging.debug(f"Initial stage_approvals for {user_email}: {initial_approvals}")

                            # Step 4: Create the request with the potentially pre-approved data
                            request_id = db_service.create_onboarding_request_composite(
                                user_email=user_email,
                                group=requested_group,
                                config_id=target_config['config_id'],
                                stage_approvals=initial_approvals
                            )
                            logging.info(f"Created request ID {request_id} for {user_email} with status 'new_unprocessed'. Pre-populated approvers for stages {list(initial_approvals.keys())}")

                            # Step 5 (OPTIONAL): Immediately advance workflow if all approvals met
                            if all_approvals_met(initial_approvals):
                                logging.info(f"All required approvals met at creation for request ID {request_id} ({user_email}). Auto-advancing workflow.")
                                handle_approval_email("system.preapproved@local", user_email, requested_group, full_config)

                        else:
                            logging.warning(f"Request for group '{requested_group}' received in mailbox {mailbox_id}, but no matching config found.")
                    
                    elif intent == 'approval':
                        if not user_email:
                            continue
                        active_request = db_service.find_active_request_by_user(user_email)
                        if active_request:
                            target_config = next((c for c in associated_configs if c['config_id'] == active_request['config_id']), None)
                            if target_config:
                                full_workflow_config = {**static_config, **mailbox_config, **target_config}
                                handle_approval_email(
                                    from_email=sender_email,
                                    user_email=user_email,
                                    requested_group=active_request['requested_group'],
                                    config=full_workflow_config
                                )
                            else:
                                logging.warning(f"Approval for '{user_email}' found, but their active request (config_id: {active_request['config_id']}) is not associated with this mailbox (ID: {mailbox_id}).")
                        else:
                            logging.warning(f"Approval received for user '{user_email}' but no active request was found.")


                except Exception as e:
                    logging.error(f"[Mailbox ID: {mailbox_id}] Exception processing UID {uid_str}: {e}", exc_info=True)


            # Update last check time AFTER processing all new emails
            db_service.update_last_check_time(last_check_timestamp_key, datetime.now().isoformat())
    except Exception as e:
        logging.error(f"[Mailbox ID: {mailbox_id}] Could not access mailbox: {e}", exc_info=True)


# ==============================================================================
# Phase 2: Action Worker (Wait & Execute)
# ==============================================================================


def process_pending_actions(config):
    """
    PHASE 2: Queries for "matured" requests for a specific config and acts on them.
    """
    config_id = config['config_id']
    try:
        mature_requests = db_service.get_mature_unprocessed_requests(config_id, config)
        if mature_requests:
            logging.info(f"[{config_id}] Found {len(mature_requests)} mature requests to process.")
        
        for request in mature_requests:
            user_email = request['user_to_onboard_email']
            requested_group = request['requested_group']
            logging.info(f"[{config_id}] Evaluating mature request for user '{user_email}'.")

            # Check if any approvers can be found. If not, it's a config error.
            required_approvers = db_service.get_required_approvers_for_stage(request, config)
            if not required_approvers:
                error_msg = f"Could not find any required approvers for stage {request['current_stage']}. Check AD configuration."
                logging.error(f"[{config_id}] {error_msg}")
                db_service.update_request_status_composite(user_email, requested_group, config_id, 'error', error_msg)
                continue 

            # Check if there are still approvers missing for the current stage.
            missing_approvers = db_service.get_missing_approvers_for_stage(request, config)
            
            if not missing_approvers:
                # This stage is pre-approved. Use the main approval handler to advance workflow.
                logging.info(f"[{config_id}] Stage {request['current_stage']} for '{user_email}' is pre-approved. Advancing workflow.")
                # Pass dummy email since no actual email is needed here.
                handle_approval_email("system.preapproved@local", user_email, requested_group, config)
            else:
                # Approvals are missing, start the standard process by sending an email.
                logging.info(f"[{config_id}] Approvals missing for '{user_email}'. Initiating approval process.")
                send_request_to_next_stage(request, config)


    except Exception as e:
        logging.error(f"[{config_id}] Error processing pending actions: {e}", exc_info=True)


# --- Approval and Reminder Logic ---


def handle_approval_email(from_email, user_email, requested_group, config):
    """
    Handles approval emails for an onboarding request (manager/system owner etc).
    If all approvals are present (even by duplicate/resent email), onboarding will progress.
    This function is recursive to handle pre-approved stages without sending unnecessary emails.
    """
    config_id = config['config_id']
    # Get the most current state of the request
    request = db_service.get_active_request(user_email, requested_group, config_id)
    if not request:
        # Special case for recursive calls where the request might now be completed.
        if from_email != "system.preapproved@local":
            logging.warning(f"[{config_id}] Approval received but no active request found for {user_email} / {requested_group}.")
        return


    if request['status'] == 'completed':
        logging.info(f"[{config_id}] Approval received for user {user_email} but onboarding already completed. Ignoring.")
        return


    # For the initial (non-recursive) call, record the approval.
    if from_email != "system.preapproved@local":
        approver_email = extract_email(from_email).lower()
        effective_approvers = db_service.get_effective_approvers_for_stage(request, config)

        if approver_email not in effective_approvers:
            logging.warning(f"[{config_id}] Unauthorized approval attempt by {approver_email} for user {user_email}.")
            return

        approval_added = db_service.add_stage_approval(request, approver_email, config)
        if not approval_added:
            logging.info(f"[{config_id}] Approval by {approver_email} was already recorded for user {user_email}. Checking status anyway.")
        
        # After attempting to add approval, get latest request state.
        request = db_service.get_active_request(user_email, requested_group, config_id)
        if not request: 
            return # Request may have been completed by add_stage_approval logic.


    # --- Workflow Progression Logic ---
    missing = db_service.get_missing_approvers_for_stage(request, config)

    if not missing:
        # Current stage complete: onboard or advance
        max_stage = max([int(k) for k in request.get('stage_approvals', {}).keys()] + [0])

        if request['current_stage'] >= max_stage:
            # Final stage: onboard user
            try:
                db_service.onboard_user_to_target_db(user_email, config)
                db_service.update_request_status_composite(user_email, requested_group, config_id, 'completed', 'Access granted after final approval.')
                send_confirmation_email(user_email, config)
                logging.info(f"[{config_id}] Onboarded user {user_email} for group {requested_group} after final approval.")
            except Exception as e:
                logging.error(f"[{config_id}] Onboarding failed for {user_email} after final approval: {e}", exc_info=True)
                db_service.update_request_status_composite(user_email, requested_group, config_id, 'error', f"Onboarding failed in target DB: {e}")
        else:
            # Not final stage: advance and re-check
            logging.info(f"[{config_id}] Stage {request['current_stage']} complete for {user_email}. Advancing to next stage.")
            advanced_request = db_service.advance_to_next_stage_composite(user_email, requested_group, config_id)
            if advanced_request:
                next_stage_missing = db_service.get_missing_approvers_for_stage(advanced_request, config)
                if not next_stage_missing:
                    logging.info(f"[{config_id}] Stage {advanced_request['current_stage']} for {user_email} is pre-approved. Continuing workflow automatically.")
                    handle_approval_email("system.preapproved@local", user_email, requested_group, config)
                else:
                    send_request_to_next_stage(advanced_request, config)
            else:
                logging.error(f"[{config_id}] Failed to advance request stage for {user_email} / {requested_group}.")
    else:
        # Stage incomplete, wait for approvals
        logging.info(f"[{config_id}] Waiting on pending approvals for stage {request['current_stage']} from: {missing}")


def process_pending_reminders(config):
    """Sends reminders for requests that have been pending for too long."""
    try:
        requests = db_service.get_pending_requests_for_reminder(config)
        for req in requests:
            missing_approvers = db_service.get_missing_approvers_for_stage(req, config)
            if missing_approvers:
                subject = f"REMINDER: Approval Required for {req['user_to_onboard_email']}"
                body = (
                    f"Hello,\n\nThis is a reminder that your approval is still required for user "
                    f"'{req['user_to_onboard_email']}' to access '{req['requested_group']}'.\n\n"
                    f"Thank you,\n{config['team_alias']}"
                )
                send_email(missing_approvers, subject, body, config)
                db_service.update_request_status_composite(
                    req['user_to_onboard_email'], req['requested_group'], req['config_id'],
                    req['status'], f"Reminder sent to: {', '.join(missing_approvers)}"
                )
    except Exception as e:
        logging.error(f"[{config['config_id']}] Get pending reminders failed: {e}")


# --- Email Sending Helpers ---


def send_confirmation_email(user_email, config):
    subject = f"Welcome! Your Access to {config['team_alias']} is Granted"
    body = f"Hello,\n\nYour account ({user_email}) has been successfully onboarded.\n\nBest regards,\n{config['team_alias']}"
    send_email([user_email], subject, body, config)


def send_request_to_next_stage(request, config):
    """Sends an approval request email to the required approvers for the current stage."""
    stage_num = request['current_stage']
    user_email = request['user_to_onboard_email']
    group = request['requested_group']
    
    approvers = db_service.get_missing_approvers_for_stage(request, config)  # Only MISSING approvers
    stage_name = "Manager" if stage_num == 1 else f"Stage {stage_num} Owner"
    
    if not approvers:
        # This case should ideally be handled by the pre-approval logic in handle_approval_email
        logging.warning(f"[{config['config_id']}] send_request_to_next_stage called for stage {stage_num} for user {user_email}, but no missing approvers found. Workflow should have auto-advanced.")
        return

    subject = f"ACTION REQUIRED: Approve Onboarding for {user_email}"
    body = (
        f"Hello,\n\nThe user '{user_email}' has requested access to the '{group}' system, "
        f"which requires your approval.\n\nPlease reply to this email with 'Approved' or 'Rejected'.\n\n"
        f"Thank you,\n{config['team_alias']}"
    )
    send_email(approvers, subject, body, config)
    
    new_status = f"pending_{stage_name.lower().replace(' ','_')}_approval"
    db_service.update_request_status_composite(
        user_email, group, config['config_id'], new_status, 
        f"Approval request sent to {stage_name}(s): {', '.join(approvers)}"
    )
